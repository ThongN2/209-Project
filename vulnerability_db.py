import json
import os
import logging
from typing import Dict, List, Any, Optional

logger = logging.getLogger("vulnerability-scanner.database")

# Default vulnerability database with patterns for common vulnerabilities
DEFAULT_VULNERABILITIES = {
    "sql_injection": {
        "name": "SQL Injection",
        "description": "Occurs when untrusted data is sent to an interpreter as part of a command or query.",
        "severity": "high",
        "cwe": "CWE-89",
        "patterns": {
            "python": [
                r"cursor\.execute\([^,]*\+[^,]*\)",
                r"cursor\.execute\(['\"][^'\"]*%[^'\"]*['\"]\s*%\s*",
                r"cursor\.executemany\([^,]*\+[^,]*\)",
                r"execute\(\s*[\'\"]SELECT.*\+.*[\'\"]\)"
            ],
            "javascript": [
                r"sql\s*=.*\+.*",
                r"executeQuery\(.*\+.*\)",
                r"query\(.*\+.*\)"
            ],
            "php": [
                r"mysql_query\(.*\$.*\)",
                r"mysqli_query\(.*\$.*\)",
                r"->query\(.*\$.*\)"
            ],
            "java": [
                r"createStatement\(\)\.execute\(.*\+.*\)",
                r"prepareStatement\(.*\+.*\)"
            ]
        },
        "mitigation": "Use parameterized queries or prepared statements instead of string concatenation.",
        "examples": {
            "vulnerable": [
                "cursor.execute('SELECT * FROM users WHERE username = \'' + username + '\'')",
                "query = 'SELECT * FROM users WHERE id = ' + userId"
            ],
            "remediated": [
                "cursor.execute('SELECT * FROM users WHERE username = %s', (username,))",
                "query = 'SELECT * FROM users WHERE id = ?'; db.execute(query, [userId])"
            ]
        },
        "references": [
            "https://owasp.org/www-community/attacks/SQL_Injection",
            "https://cheatsheetseries.owasp.org/cheatsheets/SQL_Injection_Prevention_Cheat_Sheet.html"
        ]
    },
    "xss": {
        "name": "Cross-Site Scripting (XSS)",
        "description": "Occurs when untrusted data is included in a web page without proper validation or escaping.",
        "severity": "high",
        "cwe": "CWE-79",
        "patterns": {
            "javascript": [
                r"document\.write\(.*\)",
                r"\.innerHTML\s*=",
                r"\.outerHTML\s*=",
                r"\.insertAdjacentHTML\(.*\)"
            ],
            "php": [
                r"echo\s+\$_POST",
                r"echo\s+\$_GET",
                r"echo\s+\$_REQUEST",
                r"echo\s+\$.*\$_"
            ],
            "python": [
                r"render\(.*request\.GET",
                r"render\(.*request\.POST",
                r"render_template\(.*request\.args"
            ]
        },
        "mitigation": "Use context-appropriate output encoding. Consider using templating systems with automatic escaping.",
        "examples": {
            "vulnerable": [
                "element.innerHTML = userProvidedContent",
                "document.write('<script>alert(\"' + message + '\");</script>')"
            ],
            "remediated": [
                "element.textContent = userProvidedContent",
                "const escapeHtml = (str) => str.replace(/[&<>\"']/g, (m) => ({ '&': '&amp;', '<': '&lt;', '>': '&gt;', '\"': '&quot;', \"'\": '&#39;' }[m]));"
            ]
        },
        "references": [
            "https://owasp.org/www-community/attacks/xss/",
            "https://cheatsheetseries.owasp.org/cheatsheets/Cross_Site_Scripting_Prevention_Cheat_Sheet.html"
        ]
    },
    "command_injection": {
        "name": "Command Injection",
        "description": "Occurs when untrusted data is sent to a system shell.",
        "severity": "high",
        "cwe": "CWE-78",
        "patterns": {
            "python": [
                r"os\.system\([^,]*\+[^,]*\)",
                r"os\.popen\([^,]*\+[^,]*\)",
                r"subprocess\.call\(['\"][^'\"]*['\"]\s*\+\s*.*,\s*shell\s*=\s*True\)",
                r"subprocess\.Popen\(['\"][^'\"]*['\"]\s*\+\s*.*,\s*shell\s*=\s*True\)"
            ],
            "javascript": [
                r"exec\([^,]*\+[^,]*\)",
                r"spawn\([^,]*\+[^,]*\)",
                r"execSync\([^,]*\+[^,]*\)"
            ],
            "php": [
                r"system\([^,]*\$[^,]*\)",
                r"exec\([^,]*\$[^,]*\)",
                r"shell_exec\([^,]*\$[^,]*\)",
                r"passthru\([^,]*\$[^,]*\)"
            ],
            "java": [
                r"Runtime\.getRuntime\(\)\.exec\(.*\+.*\)"
            ]
        },
        "mitigation": "Avoid using shell commands. If necessary, use safer alternatives (e.g., subprocess with shell=False and a list of arguments).",
        "examples": {
            "vulnerable": [
                "os.system('cat ' + user_file)",
                "exec('ls -la ' + directory)"
            ],
            "remediated": [
                "subprocess.run(['cat', user_file], shell=False, check=True)",
                "import { execFile } from 'child_process'; execFile('ls', ['-la', directory], (error, stdout, stderr) => { /* ... */ })"
            ]
        },
        "references": [
            "https://owasp.org/www-community/attacks/Command_Injection",
            "https://cheatsheetseries.owasp.org/cheatsheets/OS_Command_Injection_Defense_Cheat_Sheet.html"
        ]
    },
    "path_traversal": {
        "name": "Path Traversal",
        "description": "Occurs when untrusted input can manipulate paths to access files outside of intended directories.",
        "severity": "high", 
        "cwe": "CWE-22",
        "patterns": {
            "python": [
                r"open\(.*\+.*\)",
                r"with\s+open\(.*\+.*\)"
            ],
            "javascript": [
                r"fs\.readFile\(.*\+.*\)",
                r"fs\.readFileSync\(.*\+.*\)",
                r"fs\.writeFile\(.*\+.*\)"
            ],
            "php": [
                r"file_get_contents\(.*\$.*\)",
                r"fopen\(.*\$.*\)",
                r"include\(.*\$.*\)",
                r"require\(.*\$.*\)"
            ],
            "java": [
                r"new\s+File\(.*\+.*\)",
                r"new\s+FileInputStream\(.*\+.*\)"
            ]
        },
        "mitigation": "Validate and sanitize user input. Use path canonicalization and check against a whitelist of allowed files/directories.",
        "examples": {
            "vulnerable": [
                "open(user_provided_path + filename)",
                "fs.readFile(basePath + userInput)"
            ],
            "remediated": [
                "from pathlib import Path\nimport os\nsafe_path = os.path.normpath(os.path.join(base_dir, user_input))\nif not safe_path.startswith(base_dir):\n    raise ValueError(\"Invalid path\")",
                "const path = require('path');\nconst safePath = path.normalize(path.join(basePath, userInput));\nif (!safePath.startsWith(basePath)) {\n    throw new Error('Invalid path');\n}"
            ]
        },
        "references": [
            "https://owasp.org/www-community/attacks/Path_Traversal",
            "https://cheatsheetseries.owasp.org/cheatsheets/File_System_Security_Cheat_Sheet.html"
        ]
    },
    "insecure_deserialization": {
        "name": "Insecure Deserialization",
        "description": "Occurs when untrusted data is used to abuse the logic of an application.",
        "severity": "high",
        "cwe": "CWE-502",
        "patterns": {
            "python": [
                r"pickle\.loads\(",
                r"yaml\.load\(",
                r"eval\("
            ],
            "javascript": [
                r"eval\(",
                r"new\s+Function\("
            ],
            "php": [
                r"unserialize\(",
                r"eval\("
            ],
            "java": [
                r"ObjectInputStream\(",
                r"readObject\("
            ]
        },
        "mitigation": "Avoid deserializing untrusted data. Use safer alternatives (e.g., JSON with schema validation).",
        "examples": {
            "vulnerable": [
                "data = pickle.loads(user_input)",
                "const result = eval('(' + userProvidedJson + ')')"
            ],
            "remediated": [
                "import json\ndata = json.loads(user_input)",
                "const result = JSON.parse(userProvidedJson)"
            ]
        },
        "references": [
            "https://owasp.org/www-project-top-ten/2017/A8_2017-Insecure_Deserialization",
            "https://cheatsheetseries.owasp.org/cheatsheets/Deserialization_Cheat_Sheet.html"
        ]
    }
}

class VulnerabilityDatabase:
    """Manages vulnerability patterns and information."""
    
    def __init__(self, db_path: Optional[str] = None):
        """Initialize the vulnerability database."""
        self.db_path = db_path or os.path.join(os.path.expanduser("~"), ".vulnscan", "vulnerabilities.json")
        self.vulnerabilities = self._load_database()
        
    def _load_database(self) -> Dict[str, Any]:
        """Load vulnerability database from file or create default."""
        try:
            with open(self.db_path, 'r') as f:
                db = json.load(f)
                logger.info(f"Loaded vulnerability database from {self.db_path}")
                return db
        except (FileNotFoundError, json.JSONDecodeError) as e:
            logger.warning(f"Could not load database: {str(e)}. Using default database.")
            return self._create_default_database()
            
    def _create_default_database(self) -> Dict[str, Any]:
        """Create default vulnerability database file."""
        db_dir = os.path.dirname(self.db_path)
        
        # Create directory if it doesn't exist
        if not os.path.exists(db_dir):
            os.makedirs(db_dir)
            
        # Write default database
        with open(self.db_path, 'w') as f:
            json.dump(DEFAULT_VULNERABILITIES, f, indent=2)
            
        logger.info(f"Created default vulnerability database at {self.db_path}")
        return DEFAULT_VULNERABILITIES
    
    def save_database(self) -> None:
        """Save current database to file."""
        with open(self.db_path, 'w') as f:
            json.dump(self.vulnerabilities, f, indent=2)
        logger.info(f"Saved vulnerability database to {self.db_path}")
    
    def get_vulnerability(self, vuln_type: str) -> Optional[Dict[str, Any]]:
        """Get information about a specific vulnerability type."""
        return self.vulnerabilities.get(vuln_type)
    
    def get_patterns(self, vuln_type: str, language: str) -> List[str]:
        """Get detection patterns for a specific vulnerability and language."""
        vuln = self.get_vulnerability(vuln_type)
        if vuln and "patterns" in vuln:
            return vuln["patterns"].get(language, [])
        return []
    
    def add_vulnerability(self, vuln_type: str, vuln_data: Dict[str, Any]) -> None:
        """Add a new vulnerability type to the database."""
        self.vulnerabilities[vuln_type] = vuln_data
        self.save_database()
    
    def update_patterns(self, vuln_type: str, language: str, patterns: List[str]) -> None:
        """Update patterns for a specific vulnerability and language."""
        if vuln_type in self.vulnerabilities:
            if "patterns" not in self.vulnerabilities[vuln_type]:
                self.vulnerabilities[vuln_type]["patterns"] = {}
            self.vulnerabilities[vuln_type]["patterns"][language] = patterns
            self.save_database()
    
    def get_all_vulnerabilities(self) -> Dict[str, Any]:
        """Get all vulnerabilities from the database."""
        return self.vulnerabilities
    
    def get_severity(self, vuln_type: str) -> str:
        """Get the severity of a vulnerability type."""
        vuln = self.get_vulnerability(vuln_type)
        return vuln.get("severity", "unknown") if vuln else "unknown"
    
    def get_references(self, vuln_type: str) -> List[str]:
        """Get reference URLs for a vulnerability type."""
        vuln = self.get_vulnerability(vuln_type)
        return vuln.get("references", []) if vuln else []
    
    def get_examples(self, vuln_type: str) -> Dict[str, List[str]]:
        """Get code examples for a vulnerability type."""
        vuln = self.get_vulnerability(vuln_type)
        return vuln.get("examples", {}) if vuln else {}