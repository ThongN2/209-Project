import json
import os
import logging
from typing import Dict, List, Any, Optional

logger = logging.getLogger("vulnerability-scanner.database")

# Default vulnerability database with patterns for common vulnerabilities
DEFAULT_VULNERABILITIES = {
    "sql_injection": {
        "name": "SQL Injection",
        "description": "Occurs when user input is embedded directly in SQL queries.",
        "severity": "high",
        "cwe": "CWE-89",
        "patterns": {
            "sql": [
                r"SELECT\s+\*\s+FROM\s+.*\s+WHERE\s+.*=.*"
            ]
        },
        "mitigation": "Use prepared statements or parameterized queries.",
        "examples": {
            "vulnerable": [
                "query = \"SELECT * FROM users WHERE id = \" + user_id;"
            ],
            "remediated": [
                "cursor.execute(\"SELECT * FROM users WHERE id = ?\", (user_id,))"
            ]
        },
        "references": [
            "https://owasp.org/www-community/attacks/SQL_Injection",
            "https://cwe.mitre.org/data/definitions/89.html"
        ]
    },
    "xss": {
        "name": "Cross-Site Scripting",
        "description": "Occurs when user input is inserted into HTML without proper encoding.",
        "severity": "high",
        "cwe": "CWE-79",
        "patterns": {
            "js": [
                r"document\.write",
                r"innerHTML"
            ]
        },
        "mitigation": "Use safe DOM APIs like textContent, or HTML encoding.",
        "examples": {
            "vulnerable": [
                "document.write(userInput);",
                "element.innerHTML = userInput;"
            ],
            "remediated": [
                "element.textContent = userInput;"
            ]
        },
        "references": [
            "https://owasp.org/www-community/attacks/xss",
            "https://cwe.mitre.org/data/definitions/79.html"
        ]
    },
    "buffer_overflow": {
        "name": "Buffer Overflow",
        "description": "Occurs when a program writes data outside the bounds of allocated memory.",
        "severity": "critical",
        "cwe": "CWE-120",
        "patterns": {
            "c_cpp": [
                r"\bgets\s*\(",
                r"\bstrcpy\s*\(",
                r"\bstrcat\s*\(",
                r"\bsprintf\s*\(",
                r"\bscanf\s*\(\s*\"%s\""
            ]
        },
        "mitigation": "Use safer functions like fgets(), strncpy(), snprintf(), and ensure bounds checking.",
        "examples": {
            "vulnerable": [
                "gets(buffer);",
                "strcpy(buffer, input);"
            ],
            "remediated": [
                "fgets(buffer, sizeof(buffer), stdin);",
                "strncpy(buffer, input, sizeof(buffer) - 1);"
            ]
        },
        "references": [
            "https://owasp.org/www-community/vulnerabilities/Buffer_Overflow",
            "https://cwe.mitre.org/data/definitions/120.html"
        ]
    }
}

class VulnerabilityDatabase:
    """Manages vulnerability patterns and information."""

    def __init__(self, db_path: Optional[str] = None):
        self.db_path = db_path or os.path.join(os.path.expanduser("~"), ".vulnscan", "vulnerabilities.json")
        self.vulnerabilities = self._load_database()

    def _load_database(self) -> Dict[str, Any]:
        try:
            with open(self.db_path, 'r') as f:
                db = json.load(f)
                logger.info(f"Loaded vulnerability database from {self.db_path}")
                return db
        except (FileNotFoundError, json.JSONDecodeError) as e:
            logger.warning(f"Could not load database: {str(e)}. Using default database.")
            return self._create_default_database()

    def _create_default_database(self) -> Dict[str, Any]:
        db_dir = os.path.dirname(self.db_path)
        if not os.path.exists(db_dir):
            os.makedirs(db_dir)
        with open(self.db_path, 'w') as f:
            json.dump(DEFAULT_VULNERABILITIES, f, indent=2)
        logger.info(f"Created default vulnerability database at {self.db_path}")
        return DEFAULT_VULNERABILITIES

    def save_database(self) -> None:
        with open(self.db_path, 'w') as f:
            json.dump(self.vulnerabilities, f, indent=2)
        logger.info(f"Saved vulnerability database to {self.db_path}")

    def get_vulnerability(self, vuln_type: str) -> Optional[Dict[str, Any]]:
        return self.vulnerabilities.get(vuln_type)

    def get_patterns(self, vuln_type: str, language: str) -> List[str]:
        vuln = self.get_vulnerability(vuln_type)
        if vuln and "patterns" in vuln:
            return vuln["patterns"].get(language, [])
        return []

    def add_vulnerability(self, vuln_type: str, vuln_data: Dict[str, Any]) -> None:
        self.vulnerabilities[vuln_type] = vuln_data
        self.save_database()

    def update_patterns(self, vuln_type: str, language: str, patterns: List[str]) -> None:
        if vuln_type in self.vulnerabilities:
            if "patterns" not in self.vulnerabilities[vuln_type]:
                self.vulnerabilities[vuln_type]["patterns"] = {}
            self.vulnerabilities[vuln_type]["patterns"][language] = patterns
            self.save_database()

    def get_all_vulnerabilities(self) -> Dict[str, Any]:
        return self.vulnerabilities

    def get_severity(self, vuln_type: str) -> str:
        vuln = self.get_vulnerability(vuln_type)
        return vuln.get("severity", "unknown") if vuln else "unknown"

    def get_references(self, vuln_type: str) -> List[str]:
        vuln = self.get_vulnerability(vuln_type)
        return vuln.get("references", []) if vuln else []

    def get_examples(self, vuln_type: str) -> Dict[str, List[str]]:
        vuln = self.get_vulnerability(vuln_type)
        return vuln.get("examples", {}) if vuln else {}

    def apply_remediation(self, file_content: str, matches: List[Dict[str, Any]]) -> str:
        """Generate a remediated version of file_content by replacing vulnerable patterns."""
        updated_content = file_content

        for match_info in matches:
            vuln_type = match_info.get("pattern")

            # ðŸ”¥ extract actual matched string from nested dict
            match_data = match_info.get("match")
            if isinstance(match_data, dict):
                match_str = match_data.get("match")
            else:
                match_str = match_data

            examples = self.get_examples(vuln_type)
            remediated_examples = examples.get("remediated", [])

            if remediated_examples:
                replacement = remediated_examples[0]
            else:
                replacement = f"/* TODO: fix {match_str} */"

            if match_str:
                updated_content = updated_content.replace(match_str, replacement)

        return updated_content
